//------------------------------------------------------------------------------
//
// Map Item object that handles all information about one Item
//
// Cre 2004-02-17 Pma
//
//------------------------------------------------------------------------------
unit MapPoint;

interface

uses
  SysUtils,     // String conversions
  Types,        // TPoint
  Math,         // Mathematics
  Graphics,     // TCanvas
  StrUtils,     // Ansi Strings

  GenUtils,         // My utils
  MapImage,         // Map Image
  MapItemType,      // TMapItemType
  MapItemTypeList,  // TMapItemTypeList
  GeomUtils;        // Geometrical utilities

const

  ptWdtDefault  = 30; // Default wdt of a point or trap for a line/area

  msMoveSize    = 8;  // Size of the middle move square
  msSclSize     = 4;  // Size of the corner scale squares
  msRotSize     = 4;  // Size of the rotation square
  msRotLineSize = 50; // Length of the rotation line
  msPointSize   = 2;  // Size of the edit points on lines and areas

  DelmiterChar = ';'; // Delimiter char used for saving map items

type

  TMapSelPoint = (msNone,   // Nothing selected
                  msMove,   // Middle Move box selected
                  msSclLU,  // Scale Left Up selected
                  msSclLD,  // Scale Left Down selected
                  msSclRU,  // Scale Right Up selected
                  msSclRD,  // Scale Right Down selected
                  msRot,    // Rotation selected
                  msPoint,  // Existing Point selected
                  msLine);  // Existing Line selected

  // The Map Point class

  TMapPoint = class(TObject)
  private
    ItemName      : string;          // Name of the Map Point
    ItemType      : TMapItemType;    // Type of map point (extended one)
    ItemPoints    : array of TPoint; // Array of TPoints (area, line, point)
    ItemPointsLen : integer;         // Number of coordinates in this point
    ItemWdt       : integer;         // Width/trap of the Map Point (search)
    ItemDesc      : string;          // Description of the Map Point
    ItemDirty     : boolean;         // True id changed from loaded
  public

    // Create constructors

    constructor Create; overload;
    constructor Create(TypeList : TMapItemTypeList;
                       Name     : string;
                       TypeName : string;
                       TypeGeom : TMapItemGeometry;
                       xyPairs  : string; // String with xy pairs x,y,x,y...
                       Wdt      : integer;
                       Desc     : string); overload;

    constructor Create (TypeList : TMapItemTypeList;fileStr : string); overload;

    // Read only functions

    function InqName       : string; // Return name of point
    function InqType       : TMapItemType;
    function InqTypeName   : string;  // Return name of the point type (City...)

    function InqGeometry   : TMapItemGeometry; // Return internal item type (line, point, area)
    function InqGeometryName : string; // Return internal item type as a name
    function InqVisible      : boolean;
    function InqPointLen   : integer; // Return number of coordinates
    function InqPos (index : integer) : TPoint; // Return xy-coord of index
    function InqMidPoint   : TPoint;    // Return the middle of the object
    function InqWdt        : integer;  // Return the Wdt/trap of item

    function InqDesc       : string;   // Return the description

    function InqAtPos (pMap : TPoint) : boolean; // Calc if point is within XY
    function InqAtPosSelection (mp : TMapPoint; pMap : TPoint; scl : real; var index : integer): TMapSelPoint;
    function InqAtPoint (pMap : TPoint) : integer;
    function InqAtLine  (pMap : TPoint) : integer;


    function InqDirty : boolean;  // Return if object is dirty/updated

    // Return the string holding the identity properties

    function InqSaveStr : string; // Return the string used when saving a point

    //--- Draw functions -------------------------------------------------------

    function InqExt : TRect; // Return the extent of the item

    procedure Draw (pMap : TMapImage; bPnt : boolean = false; bXor : boolean = false);

    // Move the item

    procedure Move   (pDist : TPoint); overload ;

    // Move a point (index) in the item

    procedure Move   (index : integer; pMap : TPoint); overload ;

    // Scale item around a mid point with proportional scale

    procedure Scale  (pMid : TPoint; scl : real); overload ;

    // Scale item around a mid point with different X / Y scale

    procedure Scale  (pMid : TPoint; sclX,sclY : real); overload;

    // ROtate around a mid point

    procedure Rotate (pMid : TPoint; ang : real);

    // Update functions

    procedure SetName (Name : string); // Set new Name
    procedure SetDesc (desc : string); // Set new description
    procedure SetType (itl : TMapItemTypeList; it : TMapItemType);    // Set new item type

    procedure AddPoint (X,Y : integer); overload; // Add a new coord to point
    procedure AddPoint (p : TPoint); overload;    // Same
    procedure AddPoint (index:integer ; p : TPoint) ; overload; // Add at index

    procedure DelPoint (index:integer); // Delete at index

    procedure SetPoint (index: integer ; p : TPoint);

    procedure SetDirty (d : boolean); // Set the dirty flag

    function Copy : TMapPoint;
  private

    procedure AddPointsFromStr (xyPairs : string);

end; // End of TMapPoint

implementation

uses  MapData;

//------------------------------------------------------------------------------
//                              Constructors
//------------------------------------------------------------------------------
// Create the Map Data Object without data
//
constructor TMapPoint.Create();
begin
  inherited Create;

  // Initialize all data in the object

  ItemName := '';                   // No Name
  ItemType := nil;                  // Unknown type
  ItemPointsLen := 0;               // No coordinates yet
  ItemWdt  := ptWdtDefault;         // Default wdt/trap
  ItemDesc := '';                   // No description
  ItemDirty := false;               // Not changed yet
end;
//------------------------------------------------------------------------------
// Create the Map Data Object with data
//
constructor TMapPoint.Create (
    TypeList : TMapItemTypeList; // Pointer to list of all types
    Name     : string;           // Name of the Map item
    TypeName : string;           // Map Item Type Name
    TypeGeom : TMapItemGeometry;
    xyPairs  : string;           // String with coordinates
    Wdt      : integer;          // Width of the item point
    Desc     : string);          // Sescription of item
begin
  Create(); // Use the default settings

  // Initialize all data in the object

  ItemName := Name;           // Set the name of the item
  ItemType := TypeList.Add(TypeName, TypeGeom);  // Create with the right code
  AddPointsFromStr (xyPairs); // Add all points
  ItemWdt  := Wdt;            // Set width / trap
  ItemDesc := Desc;           // Set description

  ItemDirty := false;
end;
//------------------------------------------------------------------------------
// Create the Map Data Object with all data contained in a string
//
constructor TMapPoint.Create(TypeList : TMapItemTypeList; fileStr : string);
var
  index : integer;
  part  : integer;
  sTmp  : string;
  sIt   : string;
  sGt   : string;
  i     : integer;
  gt    : TMapItemGeometry;
begin
  Create();

  // Start walking the string

  part  := 0;
  index := 1;
  while (index <= Length(fileStr)) do
    begin

      // Get next string

      sTmp := StringNxtDel(index, fileStr, DelmiterChar);
      case part of
        0: ItemName := sTmp;  // Name of the Map point
        1:
          begin
            // if only one-two char, its old style, use it

            if (length(sTmp) < 3) then
              begin
                ItemType := TypeList.Add (sTmp[1]); // Map Point Type Name
              end
            else
              begin
                // Look for ' (comma)

                for i := 1 to length(sTmp) do
                  if sTmp[i] = ',' then
                    begin
                      sIt := AnsiLeftStr(sTmp,i-1);
                      sGt := AnsiRightStr(sTmp,length(sTmp) - i);
                      case sGt[1] of
                      'L' : gt := gtLine;
                      'A' : gt := gtArea;
                      else
                        gt := gtPoint;
                      end;
                      ItemType := TypeList.Add (sIt, gt);
                    end;
              end;
          end;
        2: AddPointsFromStr (sTmp); // Points XY-pairs in a string
        3: ItemWdt := Max(StringToInt(sTmp),10); // Point width / trap
        4: ItemDesc := sTmp; // Description
      end;

      // Step to next line part

      part := part + 1;
    end;
  ItemDirty := false;
end;
//------------------------------------------------------------------------------
// Add points from a string
//
procedure TMapPoint.AddPointsFromStr (xyPairs : string);
var
  i     : integer;
  x     : integer;
  y     : integer;
  sTemp : string;  // temp string with number
  xPair : boolean; // xPair means that next number is an X
begin

  // walk all xypairs string and add them to ItemPoints array
  // x1,y1,x2,y2,xN,yN is the simple syntax

  sTemp := '';
  xPair := true;
  x := 0;
  for i := 1 to length(xyPairs) do
    begin
      if xyPairs[i] = ',' then
        begin
          if xPair then
            begin
              if length(sTemp) > 0 then
                x := StrToInt(stemp)
              else
                x := 0;
              xPair := false;
            end
          else
            begin
              if length(sTemp) > 0 then
                y := StrToInt(stemp)
              else
                y := 0;

              // Add this point

              SetLength(ItemPoints, ItemPointsLen + 1);
              ItemPoints[ItemPointsLen].X := x;
              ItemPoints[ItemPointsLen].Y := y;
              ItemPointsLen := ItemPointsLen + 1;

              xPair := true;
              x := 0;
            end;
          sTemp := '';
        end
      else
        begin
          // Use numbers only

          if (xyPairs[i] >= '0') and (xyPairs[i] <= '9') then
            sTemp := sTemp + xyPairs[i];
        end;
    end;

  // Take care of any leftovers (if complete xy-pair)

  if (not xPair) and (x <> 0) and (length(sTemp) > 0) then
    begin
      // Add this point

      SetLength(ItemPoints, ItemPointsLen + 1);
      ItemPoints[ItemPointsLen].X := x;
      ItemPoints[ItemPointsLen].Y := StrToInt(sTemp);
      ItemPointsLen := ItemPointsLen + 1;
    end;
end;
//------------------------------------------------------------------------------
// Return the string representing an item (used for saving)
//
function TMapPoint.InqSaveStr : string;
var
  sTmp : string;
  i    : integer;
begin

  // Add name (if any ; (semicolon) double it)

  sTmp := StringAddDel(ItemName, DelmiterChar) + DelmiterChar;

  // Add Item type name

  sTmp := sTmp + ItemType.InqName() + ',';

  // Add Item geometry type name

  sTmp := sTmp + ItemType.InqGeometryName() + DelmiterChar;

  // Add all points (as xypairs = x,y)

  for i := 0 to High(ItemPoints) do
    begin
      if i > 0 then
        sTmp := sTmp + ',';

      sTmp := sTmp +
               IntToStr(ItemPoints[i].X) + ',' + IntToStr(ItemPoints[i].Y);
    end;

  sTmp := sTmp + DelmiterChar;

  // Add width of item (as number)

  sTmp := sTmp + IntToStr(ItemWdt) + DelmiterChar;

  // Add description (if any delimiter, double it)

  sTmp := sTmp + StringAddDel(ItemDesc, DelmiterChar) + DelmiterChar;

  // return the constructer string

  InqSaveStr := sTmp;
end;
//------------------------------------------------------------------------------
//                            Read only functions
//------------------------------------------------------------------------------
// Return the name of the item
//
function TMapPoint.InqName : string;
begin
  InqName := ItemName;
end;
//------------------------------------------------------------------------------
// Return the name of the item
//
function TMapPoint.InqType : TMapItemType;
begin
  InqType := ItemType;
end;
//------------------------------------------------------------------------------
// Return the type name
//
function TMapPoint.InqTypeName : string;
begin
  InqTypeName := ItemType.InqName();
end;
//------------------------------------------------------------------------------
// Return the Point Type (extended)
//
function TMapPoint.InqGeometry : TMapItemGeometry;
begin
  InqGeometry := ItemType.InqGeometry();
end;
//------------------------------------------------------------------------------
// Return the Point Type (extended)
//
function TMapPoint.InqGeometryName : string;
begin
  InqGeometryName := ItemType.InqGeometryName();
end;
//------------------------------------------------------------------------------
// Return if item is visible
//
function TMapPoint.InqVisible : boolean;
begin
  InqVisible := ItemType.InqVisible();
end;
//------------------------------------------------------------------------------
// Return the number of points
//
function TMapPoint.InqPointLen : integer;
begin
  InqPointLen := ItemPointsLen;
end;
//------------------------------------------------------------------------------
// Return the xy-coord of a point index
//
function TMapPoint.InqPos (index : integer) : TPoint;
begin
  if (index >= 0) and (index < ItemPointsLen) and (index <= High(ItemPoints)) then
    begin
      InqPos := ItemPoints[index];
    end
  else
    begin
      InqPos.X := -1;
      InqPos.Y := -1;
    end;
end;
//------------------------------------------------------------------------------
// Set the xy-coord of a point index
//
procedure TMapPoint.SetPoint (index : integer; p : TPoint);
begin
  if (index >= 0) and (index < ItemPointsLen) and (index <= High(ItemPoints)) then
    begin
      ItemPoints[index] := p;
      ItemDirty := true;
    end;
end;
//------------------------------------------------------------------------------
// Find the middle point X of this item
//
function TMapPoint.InqMidPoint : TPoint;
begin
  InqMidPoint := InqMidOfRect(InqExt());
end;
//------------------------------------------------------------------------------
// Return Wdt/Trap
//
function TMapPoint.InqWdt : integer;
begin
  InqWdt := ItemWdt;
end;
//------------------------------------------------------------------------------
// Return the description
//
function TMapPoint.InqDesc : string;
begin
  if length(ItemDesc) < 1 then
    InqDesc := 'No description available'
  else
    InqDesc := ItemDesc;
end;
//------------------------------------------------------------------------------
// Find out if this item is at a specific coordinate
//
function TMapPoint.InqAtPos (pMap : TPoint) : boolean;
begin
  InqAtPos := false; // So far no good

  // Any use to search at all ?

  if High(ItemPoints) >= 0 then
    begin

      // Depending on point type (point, line, area) do

      case ItemType.InqGeometry() of
        gtLine: // Lines
          begin
            InqAtPos := IsPtOnPolyLine
                        (ItemPoints, pMap.X, pMap.Y,round(ItemWdt/2));
          end;
        gtArea: // area
          begin
            InqAtPos := IsPtInArea (ItemPoints, pMap.X, pMap.Y);
          end;
      else // Its probably a point use the first point only
        begin
          InqAtPos := IsPntOnPnt(ItemPoints[0].X,
                               ItemPoints[0].Y,
                               pMap.X, pMap.Y, round(ItemWdt/2));

        end;
      end;
    end;
end;
//------------------------------------------------------------------------------
// Return if the object has changed
//
function TMapPoint.InqDirty : boolean;
begin
  InqDirty := ItemDirty;
end;
//------------------------------------------------------------------------------
// Draw this item
//
procedure TMapPoint.Draw (pMap : TMapImage; bPnt : boolean = false; bXor : boolean = false);
var
  i : integer;

  fm : TBrushStyle;
  pc : TColor;
  pw : integer;
  pm : TPenMode;

begin
  if pMap = nil then exit;
  
  // Set no fill, red line 3 pixel wide

  fm := pMap.DrawSetFillMode(bsClear);
  pc := pMap.DrawSetPenColor(clRed);
  pw := pMap.DrawSetPenWidth(3);
  if bXor then
    pm := pMap.DrawSetPenMode (pmNotXor)
  else
    pm := pMap.DrawSetPenMode (pmCopy);

  if (ItemType.InqGeometry() = gtLine) or (ItemType.InqGeometry() = gtArea) then
    begin
      // Draw an polyline

      for i := 0 to ItemPointsLen - 1 do
        begin
          if i = 0 then
            pMap.DrawMoveTo (ItemPoints[i])
          else
            pMap.DrawLineTo (ItemPoints[i]);

          if bPnt then pMap.DrawPoint(ItemPoints[i]);
        end;

      // If Area Close it also by drawing to the first point

      if (ItemType.InqGeometry() = gtArea) then
        pMap.DrawLineTo (ItemPoints[0])

    end
  else
    begin
      // Draw a circle at the first point in item

      pMap.DrawCircle(ItemPoints[0], round(ItemWdt / 2));
    end;

  pMap.DrawSetFillMode(fm);
  pMap.DrawSetPenColor(pc);
  pMap.DrawSetPenWidth(pw);
  pMap.DrawSetPenMode (pm);
end;
//------------------------------------------------------------------------------
// Get the extent of the point
//
function TMapPoint.InqExt : TRect;
var
  i : integer;
  fExt : TRect;
begin

  if ItemPointsLen < 1 then
    begin
      InqExt.Left   := 0;
      InqExt.Right  := 0;
      InqExt.Top    := 0;
      InqExt.Bottom := 0;
    end
  else
    begin

      // Take the first point always

      fExt := RectIncrement(ItemPoints[0],0);

      // Take the next points if any

      if ItemPointsLen > 1 then
        begin
          for i := 1 to ItemPointsLen - 1 do
            begin
              fExt := RectIncrement(fExt, ItemPoints[i]);
            end
        end
      else
        begin

          // If only one point add the width / trap

          fExt := RectIncrement(fExt, round(ItemWdt/2));
        end;

      InqExt := fExt;
    end;

end;
//------------------------------------------------------------------------------
// Move the item (all its points)
//
procedure TMapPoint.Move (pDist : TPoint);
var
  i : integer;
begin
  for i := 0 to ItemPointsLen - 1 do
    ItemPoints[i] := PntMove(ItemPoints[i],pDist);
  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Move an item (index) in the item
//
procedure TMapPoint.Move (index : integer; pMap : TPoint);
begin
  if (index >= 0) and (index < ItemPointsLen) and
     (index <= High(ItemPoints)) then
    ItemPoints[index] := pMap;
  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Scale this item. We scale from the middle of the item
//
procedure TMapPoint.Scale (pMid : TPoint; scl : real);
var
  i : integer;
begin
  if (ItemPointsLen = 1) then
    begin
      //Scale the wdt instead

      ItemWdt := round(ItemWdt * scl);
    end
  else
    begin
      for i := 0 to ItemPointsLen - 1 do
        ItemPoints[i] := PntSclOnMid (ItemPoints[i],scl,pMid);
    end;
  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Scale this item. We scale from the middle of the item
//
procedure TMapPoint.Scale (pMid : TPoint; sclX,sclY : real);
var
  i : integer;
begin

  if ItemPointsLen > 0 then
    begin
      if (ItemPointsLen = 1) then
        begin
          //Scale the wdt instead

          ItemWdt := round(ItemWdt * sclX);
        end
      else
        begin
          for i := 0 to ItemPointsLen - 1 do
            ItemPoints[i] := PntSclOnMid (ItemPoints[i],sclX,sclY,pMid);
        end;
    end;
  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Rotate this item. We rotate from the middle of the item
//
procedure TMapPoint.Rotate (pMid : TPoint; ang : real);
var
  i : integer;
begin

  if ItemPointsLen > 0 then
    begin

      for i := 0 to ItemPointsLen - 1 do
          ItemPoints[i] := PntRotate(pMid, ItemPoints[i], ang);
    end;
  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Find if point is at a point in MapPoint
//
function TMapPoint.InqAtPoint (pMap : TPoint) : integer;
var
  i : integer;
begin
  InqAtPoint := -1;

  for i := 0 to ItemPointsLen - 1 do
    begin
      if IsPntOnPnt (pMap, ItemPoints[i], msPointSize * 3) then
        begin
          InqAtPoint := i;
          Exit;
        end;
    end;
end;
//------------------------------------------------------------------------------
// Find if point is at a line
//
function TMapPoint.InqAtLine (pMap : TPoint) : integer;
var
  i : integer;
begin
  InqAtLine := -1;

  // Walk all line segments

  for i := 0 to ItemPointsLen - 2 do
    begin
      if IsPtOnLine(ItemPoints[i].X,ItemPoints[i].Y,
                    ItemPoints[i+1].X,ItemPoints[i+1].Y,
                    pMap.X,pMap.Y, msPointSize) then
        begin
          InqAtLine := i;
          Exit;
        end;
    end;

  // test also the last to the first if point type = area

  if (ItemType.InqGeometry() = gtArea) and (ItemPointsLen > 2) then
    if IsPtOnLine(ItemPoints[ItemPointsLen -1].X,ItemPoints[ItemPointsLen-1].Y,
                    ItemPoints[0].X,ItemPoints[0].Y,
                    pMap.X,pMap.Y, msPointSize) then
      InqAtLine := ItemPointsLen - 1;
end;
//------------------------------------------------------------------------------
// Find out if the cursor is over one of the selection frame squaers
//
function TMapPoint.InqAtPosSelection (mp : TMapPoint; pMap : TPoint;
                              scl : real; var index : integer) : TMapSelPoint;
var
  p, m : TPoint;
  r : TRect;
  i : integer;
begin
  InqAtPosSelection := msNone;
  index := -1;

  if mp <> nil then
    begin
      m := mp.InqMidPoint();

      // Test if it is one of the points itself

      if ItemPointsLen > 1 then
        begin
          i := InqAtPoint(pMap);
          if i >= 0 then
            begin
              index := i;
              InqAtPosSelection := msPoint;
              exit;
            end;
        end;

      // Test if it is one of the lines

      index := InqAtLine(pMap);
      if index >= 0 then
        begin
          InqAtPosSelection := msLine;
          exit;
        end;

      // Test the middle move first

      if IsPntInRect(pMap,RectIncrement(m,round(msMoveSize/scl))) then
        begin
          InqAtPosSelection := msMove;
          exit;
        end;

      // Test if on the scale squares

      r := mp.InqExt();
      p.X := r.Left;
      p.Y := r.Top;
      if IsPntInRect(pMap,RectIncrement(p,round(msSclSize/scl))) then
        begin
          InqAtPosSelection := msSclLU;
          exit;
        end;

      p.X := r.Left;
      p.Y := r.Bottom;
      if IsPntInRect(pMap,RectIncrement(p,round(msSclSize/scl))) then
        begin
          InqAtPosSelection := msSclLD;
          exit;
        end;

      p.X := r.Right;
      p.Y := r.Top;
      if IsPntInRect(pMap,RectIncrement(p,round(msSclSize/scl))) then
        begin
          InqAtPosSelection := msSclRU;
          exit;
        end;

      p.X := r.Right;
      p.Y := r.Bottom;
      if IsPntInRect(pMap,RectIncrement(p,round(msSclSize/scl))) then
        begin
          InqAtPosSelection := msSclRD;
          exit;
        end;

      // Test if in the rotation box

      if (ItemType.InqGeometry() = gtArea) or (ItemType.InqGeometry() = gtLine) then
        begin
          p.X := m.X + round(msRotLineSize/scl);
          p.Y := m.Y;
          if IsPntInRect(pMap,RectIncrement(p,round(msRotSize/scl))) then
            begin
              InqAtPosSelection := msRot;
              exit;
            end;
        end;
    end;

end;
//------------------------------------------------------------------------------
//                              Update functions
//------------------------------------------------------------------------------
// Change Name
//
procedure TMapPoint.SetName (Name : string);
begin
  ItemName := Name;
  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Change description
//
procedure TMapPoint.SetDesc (Desc : string);
begin
  ItemDesc := Desc;
  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Set type
//
procedure TMapPoint.SetType (itl : TMapItemTypeList; it : TMapItemType);
var
  oldGt, newGt : TMapItemGeometry;
  pnt : TPoint;
  i   : integer;
begin
  if it <> nil then
    begin

      // Remember the old geometrical type

      oldGt := ItemType.InqGeometry;

      // Set the new item type

      ItemType := it;

      // Get the new geometrical type

      newGt := ItemType.InqGeometry();

      // Find out if the geometrical shape has altered

      if (oldGt = gtPoint) and ((newGt = gtLine) or (newGt = gtArea)) then
        begin

          //--- Change from point to line or area -------------------------

          // Get the middle (first point)

          pnt := InqPos(0);
          i := round(ItemWdt/2);

          // Build a diamond (standing square)
          //      by moving forst point and add three new point

          pnt.Y := pnt.Y - i;
          SetPoint(0,pnt);

          pnt.X := pnt.X + i;
          pnt.Y := pnt.Y + i;
          AddPoint(pnt);

          pnt.X := pnt.X - i;
          pnt.Y := pnt.Y + i;
          AddPoint(pnt);

          pnt.X := pnt.X - i;
          pnt.Y := pnt.Y - i;
          AddPoint(pnt);
        end
      else if (newGt = gtPoint) and ((oldGt = gtLine) or (oldGt = gtArea)) then
        begin

          //--- Change from area or line to point -------------------------

          // Get the mid of the area or line

          pnt := InqMidPoint();

          // remove all points, but the first

          for i := 1 to ItemPointsLen - 1 do
            DelPoint(1);

          // Add the middle as new pos

          SetPoint(0,pnt);
          ItemWdt := 30;
        end;
      ItemDirty := true;
    end;
end;
//------------------------------------------------------------------------------
// Add a new point to the object
//
procedure TMapPoint.AddPoint (X,Y : integer);
begin
  SetLength(ItemPoints, (ItemPointsLen + 1));
  ItemPoints[ItemPointsLen].X := X;
  ItemPoints[ItemPointsLen].Y := Y;
  ItemPointsLen := ItemPointsLen + 1;
  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Add a new point to the object
//
procedure TMapPoint.AddPoint (p : TPoint);
begin
  SetLength(ItemPoints, (ItemPointsLen + 1));
  ItemPoints[ItemPointsLen] := p;
  ItemPointsLen := ItemPointsLen + 1;
  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Add a new point at index + 1 and move all up
//
procedure TMapPoint.AddPoint (index : integer; p : TPoint);
var
  i : integer;
begin
  if (index >= 0) and (index <= ItemPointsLen) then
    begin
      SetLength(ItemPoints, (ItemPointsLen + 1));

      for i := ItemPointsLen downto (index + 1) do
        ItemPoints[i] := ItemPoints[i-1];

      ItemPoints[index] := p;

      ItemPointsLen := ItemPointsLen + 1;

      ItemDirty := true;
    end;
end;
//------------------------------------------------------------------------------
// Add a new point at index + 1 and move all up
//
procedure TMapPoint.DelPoint (index : integer);
var
  i : integer;
begin

  if (index >= 0) and (index < ItemPointsLen) and (index <= High(ItemPoints)) then
    begin
      // Move all points before index down on index

      for i := index to (ItemPointsLen - 2) do
        ItemPoints[i] := ItemPoints[i+1];

      ItemPointsLen := ItemPointsLen - 1;
      SetLength(ItemPoints, ItemPointsLen);
    end;

  ItemDirty := true;
end;
//------------------------------------------------------------------------------
// Copy a point and return the new
//
function TMapPoint.Copy : TMapPoint;
var
  newP : TMapPoint;
  i    : integer;
  sTmp : string;
begin
  Copy := nil;
  newP := TMapPoint.Create();
  if newP <> nil then
    begin
      newP.ItemName := ItemName;
      newP.ItemType := ItemType;
      newP.ItemWdt  := ItemWdt;
      newP.ItemDesc := ItemDesc;

      for i := 0 to ItemPointsLen - 1 do
        newP.AddPoint(ItemPoints[i]);

      newP.ItemDirty := true;
      Copy := newP;
    end;
end;
//------------------------------------------------------------------------------
// Set the dirty flag
//
procedure TMapPoint.SetDirty (d : boolean);
begin
  ItemDirty := d;
end;
//------------------------------------------------------------------------------
end.
